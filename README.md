# leetcode_exercises

### Easy 121 
尽管是easy level，但是如果让我重做的话，我未必能立刻想出来。这种想法于我而言只是灵光一现，有了就是有了，没有就是没有。中文社区有段评论，基本表达了我code的意思：官方的第二个解析方法的做法大致思路其实是这样： 假设第i天买入，minprice记下买入那天的价格，往下遍历，算出接下来每一天卖出可以得到的最大利润maxprofit，遇到更大的差值就重新赋值maxprofit，直到遍历到下一个比之前买入的价格还低的那天。更换买入时间点，即重新赋值minprice，计算下一轮每一天的最大利润，如此循环，直到遍历完整个prices，保留下来的maxprofit 就是最大利润。 中途更换买入节点的原因思考一下应该就知道，因为利润只能是后面的数减前面的数的差值。如果后面存在更大的数字，那一定是和这个最小的数得到的差值(利润)一定是更大的。
### Medium 122
我本以为是继承了easy121的思想，于是就写错了。只需要把所有上升段的差值累加起来就好了。
### Medium 209 Minimum size subarray sum
经典sliding window题目。思路很简单，但是细节上犯了一些错误。列举如下：1. 没注意到right+1有可能会溢出list index的范围；2. 先执left+=1, 再执行total=total-nums[left], 导致减错了数。以上两题我都使用了flag=-1来标记某件事是否发生过，可以作为一种经验记录下来。
