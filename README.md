# leetcode_exercises

### Easy 121 
尽管是easy level，但是如果让我重做的话，我未必能立刻想出来。这种想法于我而言只是灵光一现，有了就是有了，没有就是没有。基本思路就用一个例子来说明（理解抽象的废话不如直接看例子）：[1,5,3,6,0,7] 接下来的句子依照步骤用分号隔开，每一步代表i在这个list中的每一个index中iterate：初始双指针buy=0, sell=0；由于5比1大，sell刷新成5的指标也就是1；3比5小，比1大，buy和sell都不刷新；6比5大，sell刷新成6的指标也就是3；0比1小，buy和sell全部刷新成0的指标即4；7比0大，把sell刷新成7的指标5。buy和sell在0的位置刷新时，需要记录之前可以得到的profit=nums[sell]-nums[buy]=6-1=5. 这次刷新到最终循环结束时可以得到的profit=7-0=7。比较5和7可知7是max_profit. 
### Medium 122
我本以为是继承了easy121的思想，于是就写错了。一个反例就是[1,5,3,6,0,7], 如果按照之前121的做法，起步buy=1时买入，到sell=6时卖出，再到0时buy节点刷新，到7时卖出，得出的结果就是(6-1)+(7-0)。这么做显然是有问题的。这个例子的正确结果应该是(5-1)+(6-3)+(7-0)。事实上只需要把所有上升段的差值累加起来就好了。
### Medium 209 Minimum size subarray sum
经典sliding window题目。思路很简单，但是细节上犯了一些错误。列举如下：1. 没注意到right+1有可能会溢出list index的范围；2. 先执left+=1, 再执行total=total-nums[left], 导致减错了数。以上两题我都使用了flag=-1来标记某件事是否发生过，可以作为一种经验记录下来。
